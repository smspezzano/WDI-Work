# p_1.eat(food.shuffle.pop)
# p_1.eat(food.shuffle.pop)
 
# c_1.eating






# until @stomach.empty?
		# 	@stomach.pop
		# end


# class Chris < Person

# 	# might not need to
# 	# def initialize(allergy)
# 	# 	@allerrgy = allergy
# 	# end


	

# end

# class  Beth < Person

	

# 	def eating
# 		mix_food
# 		all_food.each do |item| 
# 			if item != @allergy
# 				@stomach.push(item)
# 				puts @stomach
# 			else 
# 				throw_up
# 			end
# 		end
# 	end

# end



# # might not need to
	# def initialize(allergy)
	# 	@allerrgy = allergy
	# end

#this can be replaced by calling .shuffle on the @food array of arrays

	# def mix_food
	# 	all_food = []
	# 	all_food.push(@food)
	# 	all_food
	# end



	# food = [pizza, pan_seared_scallops, water]
# p_1.eat(food.shuffle.pop)
	# def throw_up(food)
	# 	begin
			
	# 		# if food.include?(@allergy)
	# 		# 	@stomach = []
 
	# 	raise AllergyERR.new("You threw up! You shouldn't have eaten #{@allergy}")
	# 	end
	# 	rescue AllergyERR => err
	# 		puts #{err}
	# 	end
	# end

	


# if food.include?(@allergy)
			# 	
# food.each do |item| 
			
		# 	# use for testing
		# 	# puts "#{item}"
		# 	if item != @allergy
		# 		@stomach.push(item)

		# else 
		# 		throw_up
		# 	end


# class MalformedStoryError < ArgumentError; end
# begin
#   raise MalformedStoryError.new("The story was wrong")
# rescue MalformedStoryError => e
#  puts "There was a malformed story #{e}"
# end
 